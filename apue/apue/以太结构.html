<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head>
<meta http-equiv="X-UA-Compatible" content="IE=7">
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="content-script-type" content="text/javascript">
<meta name="version" content="neblog-1.0">
<script type="text/javascript">


document.uniqueID!=document.uniqueID&&!!location.hash&&(location.hash=location.hash); 
document.domain = location.hostname.replace(/^.*\.([\w]+\.[\w]+)$/,'$1');
window.focus();
window.getMusicTimeStamp=function(){return '97798f7075512bf5fef48f1bcc4b0c41';};
</script>
<title></title>

<style type="text/css">
<!--
body {
	background-color: #F4F4F4;
}
body,td,th {
	font-family: "宋体"}
pre {
 white-space: pre-wrap;
 word-wrap: break-word;
}
#aaa {
	background-color: #FFFFFF;
	border: thin solid #006600;
}
#main {
	border: thin none #FF0000;
	word-break:break-all;
}
.STYLE1 {
	font-size: 36px;
	color: #FF0000;
	font-weight: bold;
}
.STYLE2 {
	font-size: 24px;
	color: #0000FF;
}
-->
</style>
<meta http-equiv="Content-Type" content="text/html; charset=" />

<body>

<div align="center" class="STYLE1">linux以太网分层图及相应结构体</div>

<pre>
1. <a href="TCP-IP分层.png">TCP/IP协议分层图</a>

2. <a href="以太帧格式.png">以太网报文格式图</a>

3. <a href="mac段格式.jpg">MAC段格式图</a>
<div id="aaa">#include &lt;net/ethernet.h&gt;
struct <b>ether_header	// 与设备相关的地址结构体</b>
{
	u_int8_t  ether_dhost[ETH_ALEN];	/* 目标mac地址, 6个字节 */
	u_int8_t  ether_shost[ETH_ALEN];	/* 源mac地址, 6个字节 */
	u_int16_t ether_type;		        /* IP,ARP,ICMP,RARP等的类型 */
} __attribute__ ((__packed__));
</div>

4. <a href="ip段格式.jpg">IP段格式图</a>
<div id="aaa">#include &lt;netinet/ip.h&gt;
struct <b>iphdr	// 与设备相关的地址结构体</b>
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
	unsigned int ihl:4;                   /* ip段长度, 存在可选段；5表示没有可选段, 5*sizeof(int), 20个字节 */
	unsigned int version:4;               /* ip版本 */
#elif __BYTE_ORDER == __BIG_ENDIAN
	unsigned int version:4;	 	      /* ip版本 */
	unsigned int ihl:4;                   /* ip段长度, 存在可选段 */
#else     	                              
# error	"Please fix &lt;bits/endian.h&gt;"
#endif                                        
	u_int8_t tos;                         /* 服务类型 */
	u_int16_t tot_len;                    /* 长度：ip段+子协议段+Data段长度和 */
	u_int16_t id;                         /* 标识 */
	u_int16_t frag_off;                   /* fragment offset field */
	u_int8_t ttl;                         /* 存活期限 */
	u_int8_t protocol;                    /* 子协议类型 */
	u_int16_t check;                      /* 校验和 */
	u_int32_t saddr;                      /* 源IP地址 */
	u_int32_t daddr;                      /* 目的IP地址 */
	/*The options start here. */          
};                                    	
</div>

5. <a href="TCP段格式.png">TCP段格式图</a>
<div id="aaa">#include &lt;netinet/tcp.h&gt;
struct <b>tcphdr	// 与设备相关的地址结构体</b>
{
	u_int16_t source;		/* 源端口 */
	u_int16_t dest;			/* 目的端口 */
	u_int32_t seq;			/* 包序号 */
	u_int32_t ack_seq;		/* acknowledgement number */
#  if __BYTE_ORDER == __LITTLE_ENDIAN
	u_int16_t res1:4;		/* (unused) */
	u_int16_t doff:4;		/* data offset */
	u_int16_t fin:1;
	u_int16_t syn:1;
	u_int16_t rst:1;
	u_int16_t psh:1;
	u_int16_t ack:1;
	u_int16_t urg:1;
	u_int16_t res2:2;
#  elif __BYTE_ORDER == __BIG_ENDIAN
	u_int16_t doff:4;		/* data offset */
	u_int16_t res1:4;		/* (unused) */
	u_int16_t res2:2;
	u_int16_t urg:1;
	u_int16_t ack:1;
	u_int16_t psh:1;
	u_int16_t rst:1;
	u_int16_t syn:1;
	u_int16_t fin:1;
#  else
#   error "Adjust your &lt;bits/endian.h&gt; defines"
#  endif
	u_int16_t window;		/* window */
	u_int16_t check;		/* 校验和 */
	u_int16_t urg_ptr;		/* 可选部分 */
};
</div>


6. <a href="UDP段格式.png">UDP段格式图</a>
<div id="aaa">#include &lt;netinet/udp.h&gt;
struct <b>udphdr	// 与设备相关的地址结构体</b>
{
	u_int16_t source;		/* 源端口 */
	u_int16_t dest;			/* 目的端口 */
	u_int16_t len;			/* udp段+Data段长度和 */
	u_int16_t check;		/* 校验 */
} ;
</div>

7. struct sockaddr_in是与设备无关的标准地址结构体.(IPv4专用)
<div id="aaa">#include &lt;netinet/in.h&gt;
struct <b>sockaddr_in      // 设备无关的标准地址结构体</b>
{
	__SOCKADDR_COMMON (sin_);       // 16位, 总是AF_INET
	in_port_t sin_port;             // 端口号
	struct in_addr sin_addr;        // ip地址
	... ...
};
</div>

8. struct sockaddr_ll是与设备无关的标准地址结构体.
<div id="aaa">#include &lt;netpacket/packet.h&gt;
struct <b>sockaddr_ll	// 与设备无关的标准地址结构体</b>
{
	unsigned short	sll_family;	// 总是 AF_PACKET, 即只深入到数据链路层
	unsigned short	sll_protocol;	// 协议类型, <b>#include &lt;linux/if_ether.h&gt;</b>
					// htons(ETH_P_IP)
					// htons(ETH_P_ARP)
					// htons(ETH_P_RARP)
					// 不只这几个, 还有其他类型.
	int		sll_ifindex;	// 网卡索引, 请查看辅助操作 <a href="辅助操作.html#网卡索引">网卡索引</a>
	unsigned short	sll_hatype;	// 硬件地址类型, <b>#include &lt;net/if_arp.h&gt;</b>
					// ARPHRD_ETHER	表示为以太网
	unsigned char	sll_pkttype;	// 分组类型, <b>#include &lt;netpacket/packet.h&gt;</b>	
					// PACKET_HOST		目的mac地址为本地mac
					// PACKET_BROADCAST	目的mac地址为广播mac
					// PACKET_MULTICAST	目的mac地址为本地mac已加入到的组播mac
					// PACKET_OTHERHOST	在混杂模式下目的mac地址为其他主机mac
					// (不只这几个, 还有其他类型)这些类型只对接收到的分组有意义. 
	unsigned char	sll_halen;	// 当前网卡物理地址长度, <b>#include &lt;net/ethernet.h&gt;</b>
	unsigned char	sll_addr[8];	// 当前网卡物理地址(以太网中即mac地址), 请查看辅助操作 <a href="辅助操作.html#网卡物理地址">网卡物理地址</a>
};
</div>
由于loop 127.0.0.1网卡，是没有mac地址的，而本结构体是带有mac地址字段，因此本结构体使用过程中不能使用loop网卡。
</pre>
</body>
</html>
