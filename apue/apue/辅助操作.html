<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head>
<meta http-equiv="X-UA-Compatible" content="IE=7">
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="content-script-type" content="text/javascript">
<meta name="version" content="neblog-1.0">
<script type="text/javascript">


document.uniqueID!=document.uniqueID&&!!location.hash&&(location.hash=location.hash); 
document.domain = location.hostname.replace(/^.*\.([\w]+\.[\w]+)$/,'$1');
window.focus();
window.getMusicTimeStamp=function(){return '97798f7075512bf5fef48f1bcc4b0c41';};
</script>
<title></title>

<style type="text/css">
<!--
body {
	background-color: #F4F4F4;
}
body,td,th {
	font-family: "宋体"}
pre {
 white-space: pre-wrap;
 word-wrap: break-word;
}
#aaa {
	background-color: #FFFFFF;
	border: thin solid #006600;
}
#main {
	border: thin none #FF0000;
	word-break:break-all;
}
.STYLE1 {
	font-size: 36px;
	color: #FF0000;
	font-weight: bold;
}
.STYLE3 {
	font-size: 20px;
	font-weight: bold;
	color: #0000FF;
}

</style>
<meta http-equiv="Content-Type" content="text/html; charset=" />

<body>
<pre>
<div align="center" class="STYLE1">辅助操作</div>

<div  class="STYLE3"><a name="网卡的混杂模式" id="网卡的混杂模式"></a>1. 网卡的混杂模式</div>
在网卡设置了混杂模式的情况下, 在接收数据报文时, 网卡驱动不对任何报文做mac过滤. 
即目的为非本机mac的报文网卡驱动也会接收。

命令方式开启	$ ifconfig eth0 promisc
命令方式关闭	$ ifconfig eth0 -promisc

代码方式开启：
<div id="aaa">#include &lt;net/if.h&gt;
struct ifreq	ifr = { 0x00 } ;
strncpy( ifr.ifr_name, "eth0", IFNAMSIZ ) ;
ioctl( eth_socket, SIOCGIFFLAGS, &amp;ifr) ;
ethreq.ifr_flags |= IFF_PROMISC ;
ioctl( eth_socket,SIOCGIFFLAGS, &amp;ifr ) ;
</div>

<div  class="STYLE3"><a name="网卡索引" id="网卡索引"></a>2、网卡索引</div>
一台主机存在多网卡的情况, 因此网卡存在索引, 下面代码用来获取网卡eth0在所有网卡中索引：
<div id="aaa">#include &lt;net/if.h&gt;
struct ifreq	ifr = { 0x00 } ;
strcpy(ifr.ifr_name, "eth0");
ioctl( eth_socket, SIOCGIFINDEX, &amp;ifr);
printf( "%d\n", ifr.ifr_ifindex ) ;	// 打印索引值
</div>

<div  class="STYLE3"><a name="网卡物理地址" id="网卡物理地址"></a>3、网卡物理地址</div>
网卡的物理地址就是mac地址, 下面代码用来获取网卡eth0的mac地址：
<div id="aaa">#include &lt;net/if.h&gt;
struct ifreq	ifr = { 0x00 } ;
strcpy( ifr.ifr_name, "eth0" ) ;
ioctl( eth_socket, SIOCGIFHWADDR, &amp;ifr ) ;
for( int i = 0 ; i < ETHER_ADDR_LEN ; i++ )
	printf( "0x%x:", ifr.ifr_hwaddr.sa_data[i] ) ;
</div>
		
<div  class="STYLE3"><a name="报文构造" id="报文构造"></a>4. 报文构造</div>
若IP_HDRINCL未开启	IP段报文由协议自动构造, 不需要我们关心. 
若IP_HDRINCL开启		IP段报文需要我们手动构造. 构造时, 若标识字段设置为0, 那校验字段就由内核来维护. 
开启IP_HDRINCL的代码：
<div id="aaa">const int	on =1;
setsockopt (sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) ;
</div>


<div  class="STYLE3">5. 数据链路层的bind和connect</div>
bind	用于报文接收端, 目的是过滤接收报文. read和recv在bind调用后才能使用, 否则使用recvfrom. 
connect	用于报文发送端, 目的是定向发送报文. write和send在connect调用后才能使用, 否则使用sendto. 
若不调用它们, 代表不做过滤或定向.
原始套接字是非面向连接的, 所以较常使用sendto和recvfrom. bind和connect较少被使用.

<table width="100%" border="1" align="center" cellpadding="3" cellspacing="0" bordercolor="#009900" bgcolor="#CCFFFF">
  <tr>
    <td align="left" valign="top"><b>应用层</b></td>
    <td>绑定struct sockaddr_in结构体对象. 
struct sockaddr_in是与设备无关的标准地址结构体.
struct sockaddr_in结构体中存在ip地址字段和端口字段.
因此一经绑定, 就只接收匹配的ip地址和匹配的端口的报文.
否则，默认动作是不接收所有报文.</td>
  </tr>
  <tr>
    <td align="left" valign="top"><b>网络层</b></td>
    <td>在linux中没有被支持.</td>
  </tr>
  <tr>
    <td align="left" valign="top" nowrap="nowrap"><b>数据链路层</b></td>
    <td>绑定struct sockaddr_ll结构体对象.
struct sockaddr_ll也是与设备无关的标准地址结构体.
struct sockaddr_ll结构体中只存在ip地址字段, 不存在端口字段, 也就是说原始套接字是没有端口概念的.
因此一经绑定, 就只能过滤掉不匹配的ip地址的报文. 
否则，默认动作是接收所有报文.</td>
  </tr>
</table>

bind函数使用示例: 利用AF_PACKET协议族中SOCK_RAW类型的套接字实现ARP

服务器端	bind
<div id="aaa">struct sockaddr_ll	my_addr = { 0x00 } ;
my_addr.sll_family	= AF_PACKET ;
my_addr.sll_protocol	= htons(ETH_P_ARP) ;
my_addr.sll_ifindex	= 2 ;	// 网卡索引, 2表示是eth0, 请查看辅助操作 <a href="#网卡索引">网卡索引</a>.
my_addr.sll_hatype	= ARPHRD_ETHER ;
my_addr.sll_pkttype	= PACKET_HOST ;
my_addr.sll_halen	= ETH_ALEN ;	
my_addr.sll_addr[8]	// 填充本机的物理地址, 请查看辅助操作 <a href="#网卡物理地址">网卡物理地址</a>.

// 将套接字与本地地址对象my_addr
bind( sockfd, (struct sockaddr *)&amp;my_addr, sizeof(my_addr) ) ;

// 接收方式1
recvform( sockfd, message_buffer, message_length, &amp;from, &amp;fromlen ) ;
// 接收方式2
recv( sockfd, message_buffer, message_length, 0 );
// 接收方式3
read( sockfd, message_buffer, message_length );
</div>

客户端	connect
<div id="aaa">struct sockaddr_ll	target_addr = { 0x00 } ;
target_addr.sll_family	= AF_PACKET ;
target_addr.sll_protocol= htons(ETH_P_ARP) ;
target_addr.sll_ifindex	= 2 ;	// 网卡索引, 2表示是eth0, 请查看辅助操作 <a href="#网卡索引">网卡索引</a>.
target_addr.sll_hatype	= ARPHRD_ETHER ;
target_addr.sll_pkttype	= PACKET_BROADCAST ;
target_addr.sll_halen	= ETH_ALEN ;
target_addr.sll_addr[8]	// 填充本机的物理地址, 请查看辅助操作 <a href="#网卡物理地址">网卡物理地址</a>.

// 将套接字与本地地址对象my_addr
connect( sockfd, (struct sockaddr *)&amp;target_addr, sizeof(target_addr) ) ;

// 发送方式1
sendto( sockfd, message_buffer, message_length, 0, (struct sockaddr *)&amp;target_addr, sizeof(target_addr) ) ;
// 发送方式2
send( sockfd, message_buffer, message_length, 0 ) ;
// 发送方式3
send( sockfd, message_buffer, message_length ) ;
</div>

</pre>
</body>
</html>
